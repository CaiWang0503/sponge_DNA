## JAGS model written for boral version 2.0 on 2021-12-08 22:46:35 ##

 model {
	 ## Data Level ## 
	 for(i in 1:n) {
		 for(j in 1:p) { eta[i,j] <- inprod(lv.coefs[j,2:(num.lv+1)],lvs[i,]) + row.coefs.ID1[row.ids[i,1]] }
		 y[i,1] ~ dbin(phi(lv.coefs[1,1] + eta[i,1]),1)

		 y[i,2] ~ dbin(phi(lv.coefs[2,1] + eta[i,2]),1)

		 y[i,3] ~ dbin(phi(lv.coefs[3,1] + eta[i,3]),1)

		 y[i,4] ~ dbin(phi(lv.coefs[4,1] + eta[i,4]),1)

		 y[i,5] ~ dbin(phi(lv.coefs[5,1] + eta[i,5]),1)

		 }
	 ## Latent variables ##
	 for(i in 1:n) { for(k in 1:num.lv) { lvs[i,k] ~ dnorm(0,1) } } 

	 ## Process level and priors ##
	 for(j in 1:p) { lv.coefs[j,1] ~ dnorm(0,0.1) } ## Separate response intercepts

	 for(i in 1:n.ID[1]) { row.coefs.ID1[i] ~ dnorm(0, pow(row.sigma.ID1,-2)) } 
	 row.sigma.ID1 ~ dunif(0,30)

	 for(i in 1:(num.lv-1)) { for(j in (i+2):(num.lv+1)) { lv.coefs[i,j] <- 0 } } ## Constraints to 0 on upper diagonal
	 for(i in 1:num.lv) { lv.coefs[i,i+1] ~ dnorm(0,0.1)I(0,) } ## Sign constraints on diagonal elements
	 for(i in 2:num.lv) { for(j in 2:i) { lv.coefs[i,j] ~ dnorm(0,0.1) } } ## Free lower diagonals
	 for(i in (num.lv+1):p) { for(j in 2:(num.lv+1)) { lv.coefs[i,j] ~ dnorm(0,0.1) } } ## All other elements

	 }
